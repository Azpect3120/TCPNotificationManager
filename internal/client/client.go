package client

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net"

	"github.com/Azpect3120/TCPNotificationManager/internal/events"
	"github.com/Azpect3120/TCPNotificationManager/internal/logger"
)

// Function symbol used to configure the client
type ClientOptsFunc func(*ClientOpts)

// Options used to configure the client
type ClientOpts struct {
	// Address to connect to
	Addr string

	// Port to connect to
	Port int

	// Use TLS to secure the connection
	TLS bool
}

// Provide an address for the client to connect to.
func WithAddr(addr string) ClientOptsFunc {
	return func(opts *ClientOpts) {
		opts.Addr = addr
	}
}

// Use TLS to secure the connection.
func WithTLS() ClientOptsFunc {
	return func(opts *ClientOpts) {
		opts.TLS = true
	}
}

// Provide an port for the client to connect to.
func WithPort(port int) ClientOptsFunc {
	return func(opts *ClientOpts) {
		opts.Port = port
	}
}

// Defines the default client options, if they are not
// provided by the user.
func defaultClientOpts() ClientOpts {
	return ClientOpts{
		Addr: "127.0.0.1",
		Port: 8080,
		TLS:  false,
	}
}

// EventHandler is a function type that is used to handle events
// that are received by the server. This is built using a generic
// to accept any type of event.
//
// This type will define the function signature for the event
// handlers that are used by the server.
type EventHandler[T any] func(*TcpClient, *T)

// TcpClient is a struct that represents a TCP client.
// Client options are abstracted away from the user in a
// way that they can be provided as arguments to the NewTCPClient
// function.
//
// For an explanation of this pattern, see the following video:
// https://www.youtube.com/watch?v=MDy7JQN5MN4&t=601s
type TcpClient struct {
	// Client options.
	Opts ClientOpts

	// ID of the client. This is generated by the server.
	ID string

	// Store any errors that occur during the server's lifecycle.
	Errors []error

	// TLS configuration for the client.
	TLSConfig *tls.Config

	// EventHandlers is a map of event types to their handlers. This map
	// will be used to determine which function to call when an event is
	// received by the client.
	//
	// The key is the event name, and the value is the function to call.
	// The function is defined here as an interface{} but it should be
	// defined as the EventHandler type.
	EventHandlers map[string]interface{}

	// Logger for the client, the default option will be info level.
	Logger *logger.Logger
}

// RegisterEventHandler registers an event handler for a specific event type.
// Methods cannot have generic types, so this function will be used to register
// the event handlers for the client.
//
// The event name should match the class of event that is being handled, not the
// name of the event stored in the struct. This is because we use reflection to
// determine which handler to call.
func RegisterEventHandler[T any](client *TcpClient, eventName string, handler EventHandler[T]) {
	client.EventHandlers[eventName] = handler
}

// Create a new TCP client with the provided options. If options
// are not provided, the default options will be used. They can
// be found in the defaultClientOpts function.
func NewTCPClient(opts ...ClientOptsFunc) *TcpClient {
	client := &TcpClient{
		Opts:   defaultClientOpts(),
		ID:     "",
		Logger: logger.NewLogger(logger.WithDefaultLevel(logger.INFO), logger.WithTimestamp()),
	}

	// Apply the options to the client.
	for _, optFn := range opts {
		optFn(&client.Opts)
	}

	// Initialize the event handlers map
	client.EventHandlers = make(map[string]interface{})

	// When registering new events, make sure the event name matches the class name
	// of the event. They must be a perfect match or the event will not be handled.
	// The 3rd parameter (handler) is the function that will be called when the event
	// is received by the client.
	RegisterEventHandler(client, "ConnectionAcceptedEvent", ConnectionAcceptedHandler)
	RegisterEventHandler(client, "ClientAuthenticatedEvent", ClientAuthenticatedHandler)

	return client
}

// This function is used to configure the TLS settings for the client.
// It is only required if you intend to use TLS, otherwise, there is no
// need to run this function.
//
// The client is returned to allow for method chaining.
//
// Errors will not be handled here, they will be stored in the client's
// errors slice. If the files do not exist, or cannot be read, an error
// will be stored in the client's errors slice.
func (c *TcpClient) Configure(certPath, keyPath, serverName string) *TcpClient {
	// NOTE: Learn how to use CA certificates
	// caCert, err := os.ReadFile(caPath)
	// if err != nil {
	// 	c.Errors = append(c.Errors, err)
	// }
	//
	// certPool := x509.NewCertPool()
	// if !certPool.AppendCertsFromPEM(caCert) {
	// 	c.Errors = append(c.Errors, errors.New("Failed to append CA certificate"))
	// }

	cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		c.Errors = append(c.Errors, err)
	}

	// TODO: Remove InsecureSkipVerify
	c.TLSConfig = &tls.Config{
		// RootCAs:    certPool,
		Certificates:       []tls.Certificate{cert},
		ServerName:         serverName,
		InsecureSkipVerify: true, // ONLY FOR TESTING - NEVER IN PRODUCTION
	}

	return c
}

// Connect to the server, using the provided address and port in the
// client options. If the client is configured to use TLS, the connection
// will be secured using the TLS configuration provided.
//
// To use TLS the client must be configured using the client.Configure
// function, otherwise the connection will not be secured.
//
// The connection object is returned and can be used by the caller. The caller
// owns the memory and is responsible for closing the connection.
func (c *TcpClient) Connect() net.Conn {
	var conn net.Conn
	var err error

	if c.Opts.TLS && c.TLSConfig != nil {
		conn, err = tls.Dial("tcp", fmt.Sprintf("%s:%d", c.Opts.Addr, c.Opts.Port), c.TLSConfig)
	} else {
		conn, err = net.Dial("tcp", fmt.Sprintf("%s:%d", c.Opts.Addr, c.Opts.Port))
	}

	if err != nil {
		c.Errors = append(c.Errors, err)
	}
	return conn
}

// This function is used to close the connection to the server.
// It handles closing the connection, as well as sending the final
// disconnection event to the server.
//
// Like all methods on the TcpClient struct, errors are added to the
// client's error slice.
func (c *TcpClient) Disconnect(conn net.Conn) {
	defer conn.Close()

	bytes, err := json.Marshal(events.NewClientDisconnectingEvent(c.ID))
	if err != nil {
		c.Errors = append(c.Errors, err)
		c.Logger.Log(fmt.Sprintf("Error marshaling disconnect event: %v", err), logger.ERROR) // Log the error!
		return                                                                                // Important: Return early if marshaling fails!
	}
	c.Logger.Log(fmt.Sprintf("Disconnecting from server: %s\n", c.ID), logger.DEBUG)
	conn.Write(bytes)
}
