package client

import (
	"crypto/tls"
	"fmt"
	"net"

	"github.com/Azpect3120/TCPNotificationManager/internal/logger"
)

// Function symbol used to configure the client
type ClientOptsFunc func(*ClientOpts)

// Options used to configure the client
type ClientOpts struct {
	// Address to connect to
	Addr string

	// Port to connect to
	Port int

	// Use TLS to secure the connection
	TLS bool
}

// Provide an address for the client to connect to.
func WithAddr(addr string) ClientOptsFunc {
	return func(opts *ClientOpts) {
		opts.Addr = addr
	}
}

// Use TLS to secure the connection.
func WithTLS() ClientOptsFunc {
	return func(opts *ClientOpts) {
		opts.TLS = true
	}
}

// Provide an port for the client to connect to.
func WithPort(port int) ClientOptsFunc {
	return func(opts *ClientOpts) {
		opts.Port = port
	}
}

// Defines the default client options, if they are not
// provided by the user.
func defaultClientOpts() ClientOpts {
	return ClientOpts{
		Addr: "127.0.0.1",
		Port: 8080,
		TLS:  false,
	}
}

// TcpClient is a struct that represents a TCP client.
// Client options are abstracted away from the user in a
// way that they can be provided as arguments to the NewTCPClient
// function.
//
// For an explanation of this pattern, see the following video:
// https://www.youtube.com/watch?v=MDy7JQN5MN4&t=601s
type TcpClient struct {
	// Client options.
	Opts ClientOpts

	// ID of the client. This is generated by the server.
	ID string

	// Store any errors that occur during the server's lifecycle.
	Errors []error

	// TLS configuration for the client.
	TLSConfig *tls.Config

	// Logger for the client, the default option will be info level.
	Logger *logger.Logger
}

// Create a new TCP client with the provided options. If options
// are not provided, the default options will be used. They can
// be found in the defaultClientOpts function.
func NewTCPClient(opts ...ClientOptsFunc) *TcpClient {
	client := &TcpClient{
		Opts:   defaultClientOpts(),
		ID:     "",
		Logger: logger.NewLogger(logger.WithDefaultLevel(logger.INFO), logger.WithTimestamp()),
	}

	// Apply the options to the client.
	for _, optFn := range opts {
		optFn(&client.Opts)
	}

	return client
}

// This function is used to configure the TLS settings for the client.
// It is only required if you intend to use TLS, otherwise, there is no
// need to run this function.
//
// The client is returned to allow for method chaining.
//
// Errors will not be handled here, they will be stored in the client's
// errors slice. If the files do not exist, or cannot be read, an error
// will be stored in the client's errors slice.
func (c *TcpClient) Configure(certPath, keyPath, serverName string) *TcpClient {
	// NOTE: Learn how to use CA certificates
	// caCert, err := os.ReadFile(caPath)
	// if err != nil {
	// 	c.Errors = append(c.Errors, err)
	// }
	//
	// certPool := x509.NewCertPool()
	// if !certPool.AppendCertsFromPEM(caCert) {
	// 	c.Errors = append(c.Errors, errors.New("Failed to append CA certificate"))
	// }

	cert, err := tls.LoadX509KeyPair(certPath, keyPath)
	if err != nil {
		c.Errors = append(c.Errors, err)
	}

	// TODO: Remove InsecureSkipVerify
	c.TLSConfig = &tls.Config{
		// RootCAs:    certPool,
		Certificates:       []tls.Certificate{cert},
		ServerName:         serverName,
		InsecureSkipVerify: true, // ONLY FOR TESTING - NEVER IN PRODUCTION
	}

	return c
}

// Connect to the server, using the provided address and port in the
// client options. If the client is configured to use TLS, the connection
// will be secured using the TLS configuration provided.
//
// To use TLS the client must be configured using the client.Configure
// function, otherwise the connection will not be secured.
//
// The connection object is returned and can be used by the caller. The caller
// owns the memory and is responsible for closing the connection.
func (c *TcpClient) Connect() net.Conn {
	var conn net.Conn
	var err error

	if c.Opts.TLS && c.TLSConfig != nil {
		conn, err = tls.Dial("tcp", fmt.Sprintf("%s:%d", c.Opts.Addr, c.Opts.Port), c.TLSConfig)
	} else {
		conn, err = net.Dial("tcp", fmt.Sprintf("%s:%d", c.Opts.Addr, c.Opts.Port))
	}

	if err != nil {
		c.Errors = append(c.Errors, err)
	}
	return conn
}
